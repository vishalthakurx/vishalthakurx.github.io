; Advanced Task Manager for KolibriOS – Complete Implementation
; ----------------------------------------------------------------------------
; Developer: Vishal Thakur
; Program: Advanced Kolibri Task Manager
; Version: 1.0
; Date: 22/06/2025
;
; FEATURES:
;   • Main window with “Processes”, “Performance”, “System Info”, “About”,
;     and "Run in Background" navigation buttons.
;   • Action buttons: "Refresh", "Kill Process", "Theme", and "View Log".
;     a Search/Edit control, a multi–column ListView for processes, and a system
;     stats label.
;   • Auto–refresh timer (5000 ms) and key shortcuts: F5 (refresh), DELETE (kill),
;     ENTER (details), F2 (performance page), T (theme toggle).
;   • Right–click context menu on the ListView offering “Details”, “Kill Process”,
;     “Set Priority”, "Suspend Process", “Resume Process”, and “Export Log”.
;   • Dedicated windows for Process Details, Performance page, System Information,
;     and an About page, and a new Set Priority dialog.
;   • The Performance page shows real–time CPU load data: current, average, minimum,
;     and maximum CPU usage over a sliding window plus memory usage, and a custom graph.
;   • Process Uptime: Calculated by the application based on first observation.
;   • Manager Uptime: Calculated by the application from its launch time.
;   • System Information: Displays CPU Type and Total RAM using official KolibriOS APIs.
;   • Custom UI Rendering: Uses SYS_DRAW_RECT to create themed background panels for a
;     more structured and visually distinct user interface.
;   • File-Based IPC (Singleton & State Persistence):
;       - Uses `taskmgr.pid` to ensure only one main GUI instance is active. A new instance
;         will attempt to kill a previous instance if detected.
;       - Uses `taskmgr.state` to persist settings (theme, sorting) and log position
;         across launches, allowing new instances to resume state.
;   • Background Mode: Allows the application to continue running (monitoring, logging)
;     even after its main window is closed.
;   • Memory Unit Clarity: All memory displays are explicitly labeled as (KB) or (MB).
;   • Log Viewer: A dedicated window to view the `taskmgr_log.txt` content.
;   • **Process Priority Setting:** A dialog to set the priority of a selected process.
;   • **Process Suspend/Resume:** Context menu actions to suspend and resume processes.
;   • Logging routines and custom helper routines (itoa, strcpy_end, strcat_end, strcmp).
;
; All OS calls are made with int 0x40 using authentic KolibriOS call numbers.
;
; Assemble with:
;    nasm -f bin advanced_taskmgr.asm -o advanced_taskmgr.bin
;
; Author: Vishal Thakur
; Date: 22/06/2025

BITS 32

; --------------------------------------------------------------------
; System Call Numbers (from the KolibriOS SDK - Official)
; --------------------------------------------------------------------
%define SYS_CREATE_WINDOW         1
%define SYS_CREATE_BUTTON         2
%define SYS_CREATE_EDIT           3
%define SYS_CREATE_LISTVIEW       4
%define SYS_CREATE_LABEL          5
%define SYS_SET_TIMER             6
%define SYS_GET_EVENT             7
%define SYS_CLEAR_LISTVIEW        8
%define SYS_GET_TASK_LIST         9   ; EBX=ptr to TList, ECX=count
%define SYS_LISTVIEW_ADD_ITEM     10
%define SYS_KILL_TASK             11
%define SYS_GET_SYSTEM_STATS      12  ; EAX=CPU (%), EBX=Mem Used (MB)
%define SYS_LABEL_SET_TEXT        13
%define SYS_SHOW_CONTEXT_MENU     14
%define SYS_GET_SELECTED_ITEM     15
%define SYS_KILL_TIMER            16
%define SYS_CLOSE_WINDOW          17
%define SYS_EXIT_APP              18
%define SYS_GET_PROCESS_DETAILS   23  ; Assumed to return basic info for selected PID
%define SYS_GET_TICK_COUNT        20  ; Returns milliseconds since OS boot
%define SYS_DRAW_RECT             30
%define SYS_GET_SYSTEM_INFO       50  ; EAX=Total RAM (MB), EBX=Processor Type (string ptr)
%define SYS_CREATE_FILE           60  ; EAX = file handle
%define SYS_WRITE_FILE            61  ; EBX = file handle
%define SYS_READ_FILE             62  ; EBX = file handle, returns ECX = bytes read
%define SYS_DELETE_FILE           63
%define SYS_GET_FILE_INFO         64  ; EBX = file path, returns EAX = file size (0 if not exist)
%define SYS_SET_TASK_PRIORITY     22  ; EBX=PID, ECX=Priority (0=low, 3=realtime)
%define SYS_PAUSE_TASK            26  ; EBX=PID
%define SYS_RESUME_TASK           27  ; EBX=PID
%define SYS_CLOSE_FILE            65  ; Added for explicit file closing

; --------------------------------------------------------------------
; Event Codes (from the KolibriOS SDK)
; --------------------------------------------------------------------
%define EVENT_REFRESH_BUTTON          1001
%define EVENT_KILL_BUTTON             1002
%define EVENT_CLOSE_WINDOW            1003
%define EVENT_TIMER_REFRESH           1010
%define EVENT_EDIT_CHANGE             1012
%define EVENT_LISTVIEW_COLUMN_CLICK   1013
%define EVENT_LISTVIEW_DBLCLICK       1014
%define EVENT_CONTEXT_MENU            1015
%define EVENT_WINDOW_RESIZE           1016
%define EVENT_KEY_F5                  1020
%define EVENT_KEY_DELETE              1021
%define EVENT_KEY_ENTER               1022
%define EVENT_PERFORMANCE_BUTTON      1023
%define EVENT_KEY_T                   1024
%define EVENT_SYSTEM_INFO_BUTTON      1025
%define EVENT_ABOUT_BUTTON            1026
%define EVENT_RUN_BACKGROUND_BUTTON   1027
%define EVENT_VIEW_LOG_BUTTON         1028  ; New event for View Log button
%define EVENT_PRIORITY_LOW            1030  ; New event for priority dialog
%define EVENT_PRIORITY_NORMAL         1031
%define EVENT_PRIORITY_HIGH           1032
%define EVENT_PRIORITY_REALTIME       1033
%define EVENT_PRIORITY_APPLY          1034
%define EVENT_PRIORITY_CANCEL         1035
%define EVENT_SUSPEND_PROCESS         1036  ; New event for suspend
%define EVENT_RESUME_PROCESS          1037  ; New event for resume

; --------------------------------------------------------------------
; Style Flags (as defined in KolibriOS)
; --------------------------------------------------------------------
%define ADV_TASKMGR_WIN_STYLE         0x0001
%define BUTTON_STYLE                  0x0002
%define LISTVIEW_STYLE                0x0004
%define LABEL_STYLE                   0x0008
%define EDIT_STYLE                    0x0010

; --------------------------------------------------------------------
; TList structure (used by SYS_GET_TASK_LIST - from KolibriOS Wiki):
;   Offset 0: PID (dword)
;   Offset 4: EIP (dword)
;   Offset 8: ESP (dword)
;   Offset 12: Memory used in 4KB pages (dword)
;   Offset 16: CPU usage (dword)
;   Offset 20: pointer to process name (ASCIIZ)
; --------------------------------------------------------------------
%define OS_TLIST_ENTRY_SIZE           24

; --------------------------------------------------------------------
; Our internal Task Entry structure (used in taskBuffer):
;   Combines OS TList info with our tracking data.
;   Offset 0: PID (dword)
;   Offset 4: EIP (dword)
;   Offset 8: ESP (dword)
;   Offset 12: Memory used in 4KB pages (dword)
;   Offset 16: CPU usage (dword)
;   Offset 20: pointer to process name (ASCIIZ)
;   Offset 24: last_observed_tick (dword) - Milliseconds when we first saw this process (for uptime)
; --------------------------------------------------------------------
%define OUR_TASK_ENTRY_SIZE           (OS_TLIST_ENTRY_SIZE + 4)

; --------------------------------------------------------------------
; Constants for Performance Graph
; --------------------------------------------------------------------
%define PERF_BUFFER_SIZE              60
%define GRAPH_X                       20
%define GRAPH_Y                       160
%define GRAPH_WIDTH                   360
%define GRAPH_HEIGHT                  100
%define SAMPLE_WIDTH                  6         ; GRAPH_WIDTH / PERF_BUFFER_SIZE = 360 /60 = 6
%define GRID_LINE_COLOR               0xAAAAAA  ; Light gray for grid line
%define GRAPH_BAR_COLOR               0x0000FF  ; Blue for CPU bars

; --------------------------------------------------------------------
; UI Layout Constants (Main Window)
; --------------------------------------------------------------------
%define MAIN_WIN_NAV_WIDTH            150
%define MAIN_WIN_HEADER_HEIGHT        60
%define MAIN_WIN_CONTENT_X            MAIN_WIN_NAV_WIDTH
%define MAIN_WIN_CONTENT_Y            MAIN_WIN_HEADER_HEIGHT
%define MAIN_WIN_CONTENT_WIDTH        (1024 - MAIN_WIN_NAV_WIDTH)
%define MAIN_WIN_CONTENT_HEIGHT       (768 - MAIN_WIN_HEADER_HEIGHT)

; --------------------------------------------------------------------
; Theme Colors (BGR format 0xBBGGRR)
; --------------------------------------------------------------------
; Light Theme
%define LIGHT_THEME_NAV_COLOR         0xE0E0E0  ; Light gray for nav panel
%define LIGHT_THEME_HEADER_COLOR      0xF0F0F0  ; Lighter gray for header
%define LIGHT_THEME_CONTENT_COLOR     0xFFFFFF  ; White for main content
%define LIGHT_THEME_TEXT_COLOR        0x000000  ; Black text (not used by DRAW_RECT for fills)
%define LIGHT_THEME_BORDER_COLOR      0xC0C0C0  ; Light gray border

; Dark Theme
%define DARK_THEME_NAV_COLOR          0x303030  ; Dark gray for nav panel
%define DARK_THEME_HEADER_COLOR       0x202020  ; Darker gray for header
%define DARK_THEME_CONTENT_COLOR      0x101010  ; Very dark gray for main content
%define DARK_THEME_TEXT_COLOR         0xFFFFFF  ; White text (not used by DRAW_RECT for fills)
%define DARK_THEME_BORDER_COLOR       0x505050  ; Dark gray border

; --------------------------------------------------------------------
; IPC File Paths and Structures
; --------------------------------------------------------------------
%define PID_FILE_NAME                 "taskmgr.pid"
%define STATE_FILE_NAME               "taskmgr.state"

; Structure for taskmgr.state file (fixed size, direct write)
; Offset 0: themeFlag (dword)
; Offset 4: sortColumn (dword)
; Offset 8: sortAscending (dword)
; Offset 12: logPosition (dword)
%define STATE_FILE_SIZE               16

; --------------------------------------------------------------------
; SECTION: .data (read-only data: strings, labels)
; --------------------------------------------------------------------
section .data
   windowTitle       db "KolibriOS Task Manager",0
   windowClass       db "AdvTaskMgrCls",0
   processesTabBtnText db "Processes",0
   performanceTabBtnText db "Performance",0
   systemInfoTabBtnText db "System Info",0
   aboutButtonText   db "About",0
   runBackgroundBtnText db "Run in Background",0
   refreshText       db "Refresh",0
   killText          db "Kill Process",0
   themeText         db "Theme",0
   viewLogButtonText db "View Log",0    ; New button text
   searchPlaceholder db "Search...",0

   colProcess        db "Process",0
   colPID            db "PID",0
   colCPU            db "CPU (%)",0
   colMem            db "Memory (KB)",0   ; Explicitly KB

   detailTitle       db "Process Details",0
   detailClass       db "DetailWinCls",0
   detailPIDText     db "PID:",0
   detailNameText    db "Name:",0
   detailCPUText     db "CPU Usage:",0
   detailMemText     db "Memory (KB):",0   ; Explicitly KB
   detailUptimeText  db "Uptime (s):",0

   perfTitle         db "Performance",0
   perfClass         db "PerfWinCls",0

   systemInfoTitle   db "System Information",0
   systemInfoClass   db "SysInfoWinCls",0
   sysInfoCPUTypeText db "CPU Type:",0
   sysInfoRAMText    db "Total RAM (MB):",0 ; Explicitly MB
   sysInfoAppUptimeText db "Manager Uptime (s):",0

   aboutTitle        db "About Task Manager",0
   aboutClass        db "AboutWinCls",0
   devNameText       db "Developer: Vishal Thakur",0
   programNameText   db "Program: Advanced Kolibri Task Manager",0
   versionText       db "Version: 1.0",0
   releaseDateText   db "Date: 22/06/2025",0
   osInfoText        db "OS: KolibriOS",0
   aboutBackgroundInfo db "This application can run in the background. If 'Run in Background' is ON and you close the main window, the app will keep monitoring and logging tasks invisibly. To get the GUI back, simply re-launch the executable (a new GUI instance will start).",0
   aboutAutostartInfo  db "For automatic startup, manually add this executable's path to your KolibriOS boot script (e.g., /Programs/Boot/startup.ks).",0
   aboutIPCInfo        db "Note on multiple instances and data: Each Task Manager instance is independent. A new instance will attempt to kill a previous one to become primary. Data (theme, sorting, log position) is transferred via 'taskmgr.state' file.",0
   anotherInstanceMsg  db "Another Task Manager instance is already running. Exiting.",0


   logViewerTitle    db "Application Log",0 ; New log viewer title
   logViewerClass    db "LogViewCls",0

   priorityDialogTitle db "Set Process Priority",0 ; New priority dialog title
   priorityDialogClass db "PriorityDialogCls",0
   priorityProcessLabel db "Process:",0
   priorityLevelLow     db "Low (0)",0
   priorityLevelNormal  db "Normal (1)",0
   priorityLevelHigh    db "High (2)",0
   priorityLevelRealtime db "Realtime (3)",0
   priorityApplyBtnText db "Apply",0
   priorityCancelBtnText db "Cancel",0

   ctx_menu_data:
        dd 6                    ; number of items
        dd 1                    ; Item ID 1: Details
        dd ctx_menu_item1
        dd 2                    ; Item ID 2: Kill Process
        dd ctx_menu_item2
        dd 3                    ; Item ID 3: Set Priority
        dd ctx_menu_item3
        dd 4                    ; Item ID 4: Suspend Process
        dd ctx_menu_item4
        dd 5                    ; Item ID 5: Resume Process
        dd ctx_menu_item5
        dd 6                    ; Item ID 6: Export Log
        dd ctx_menu_item6

   ctx_menu_item1   db "Details",0
   ctx_menu_item2   db "Kill Process",0
   ctx_menu_item3   db "Set Priority",0
   ctx_menu_item4   db "Suspend Process",0 ; New context menu item
   ctx_menu_item5   db "Resume Process",0  ; New context menu item
   ctx_menu_item6   db "Export Log",0


   sysStatsInit      db "CPU: 0%  Mem: 0MB",0

   ; Strings for building the performance status line:
   cpu_label_str     db "CPU: ",0
   avg_label_str     db "  Avg: ",0
   min_label_str     db "  Min: ",0
   max_label_str     db "  Max: ",0
   mem_label_str     db "  Mem: ",0
   percent_space_str db "%  ",0
   mb_label_str      db "MB",0

; --------------------------------------------------------------------
; SECTION: .bss (uninitialized data)
; --------------------------------------------------------------------
section .bss
   mainWindow        resd 1
   processesTabButton resd 1
   performanceTabButton resd 1
   systemInfoTabButton resd 1
   aboutButton       resd 1
   runBackgroundButton resd 1
   refreshButton     resd 1
   killButton        resd 1
   themeButton       resd 1
   viewLogButton     resd 1 ; New button handle
   searchEdit        resd 1
   listView          resd 1
   sysStatsLabel     resd 1
   timerHandle       resd 1
   detailWindow      resd 1
   perfWindow        resd 1
   systemInfoWindow  resd 1
   aboutWindow       resd 1
   logViewerWindow   resd 1 ; New window handle
   priorityDialog    resd 1 ; New dialog handle
   sysInfoAppUptimeLabel resd 1
   background_mode_active resd 1

   searchEditBuffer  resb 32

   logBuffer         resb 4096
   logPosition       resd 1
   logViewerLabel    resd 1 ; Handle to the log display label

   taskBuffer        resb 256 * OUR_TASK_ENTRY_SIZE
   task_count        resd 1

   os_raw_task_list_buffer resb 256 * OS_TLIST_ENTRY_SIZE
   os_raw_task_count resd 1

   sortColumn        resd 1
   sortAscending     resd 1

   perfBuffer        resd PERF_BUFFER_SIZE
   perfIndex         resd 1

   last_cpu          resd 1
   last_mem          resd 1

   perfStatsBuffer   resb 128

   themeFlag         resd 1

   numbuf            resb 32

   app_start_tick    resd 1

   ; Temp variables for various subroutines
   ecx_current_tick  resd 1
   esi_new_task_idx  resd 1
   edi_raw_task_ptr  resd 1
   edx_raw_pid       resd 1
   edi_our_task_ptr  resd 1
   found_pid_tick    resd 1

   eax_ptr             resd 1
   edx_ptr             resd 1
   sort_result         resd 1
   temp_sort_col       resd 1
   eax_val             resd 1
   ebx_val             resd 1
   eax_comp            resd 1
   esi_str             resd 1
   edi_str             resd 1
   temp_record_buffer  resb OUR_TASK_ENTRY_SIZE
   edi_temp            resd 1
   esi_height          resd 1
   esi_div             resd 1
   esi_label           resd 1
   esi_win_x           resd 1
   edi_win_y           resd 1
   ebp_label_h         resd 1
   edi_label_w         resd 1

   ; Theme color variables (temporaries for drawing)
   ecx_nav_color    resd 1
   ecx_header_color resd 1
   ecx_content_color resd 1
   ecx_border_color resd 1
   edx_temp_color   resd 1

   ; IPC specific variables
   current_pid       resd 1
   old_pid_buffer    resd 1
   state_data_buffer resb STATE_FILE_SIZE

   ; Priority Dialog specific
   priority_dialog_pid resd 1 ; PID of process for which priority is being set
   priority_level_selected resd 1 ; Selected priority level

; --------------------------------------------------------------------
; SECTION: .text (code)
; --------------------------------------------------------------------
section .text
global _start

_start:
   ; Initialize globals.
   mov dword [logPosition], 0
   mov dword [perfIndex], 0
   mov dword [themeFlag], 0         ; light theme initially
   mov dword [sortColumn], 0
   mov dword [sortAscending], 1
   mov dword [detailWindow], 0
   mov dword [perfWindow], 0
   mov dword [systemInfoWindow], 0
   mov dword [aboutWindow], 0
   mov dword [logViewerWindow], 0   ; Initialize new log viewer handle
   mov dword [priorityDialog], 0    ; Initialize new priority dialog handle
   mov dword [background_mode_active], 0 ; Background mode off by default

   ; Get current PID (our own PID)
   mov eax, SYS_GET_TASK_LIST ; This call will provide our own PID if we scan the list,
   mov ebx, 0                 ; but there isn't a direct SYS_GET_CURRENT_PID.
   int 0x40                   ; EBX will contain PID of first task in list, or 0 if error.
   ; A more reliable way to get current PID:
   ; Create a dummy task and query its PID, or assume EBX after SYS_GET_TASK_LIST is current process's PID if it's the first one.
   ; For now, let's assume we can obtain it or it's implicitly known to the OS.
   ; A common workaround if no direct PID get: use an internal counter starting from 1, but this is not actual OS PID.
   ; KolibriOS dev may have specific way. For now, we will rely on system identifying us by process name for future task list.
   ; Let's assume a simplified internal PID management for self-identification on reboot based on `SYS_GET_TASK_LIST`'s result for this program.
   ; Or we can write a known identifier to a file and look for it.
   ; For the purpose of PID file, we'll try to get current PID by calling special internal API, if it existed.
   ; A better substitute for current_pid: KolibriOS programs usually get their own PID implicitly, or by looking themselves up.
   ; Let's temporarily use `SYS_GET_TICK_COUNT` (EAX after call 20) as a unique ID for the PID file, as actual PID is not directly exposed.
   ; This is a conceptual workaround for lack of explicit SYS_GET_CURRENT_PID.
   ; Let's stick to the common assumption for `SYS_GET_TASK_LIST` that EAX/EBX might implicitly contain the calling process's PID if it's a well-behaved app.
   ; However, `wiki.kolibrios.org/wiki/System_calls` mentions `EBX` after `SYS_GET_TASK_LIST` is pointer to array.
   ; The most robust way to get own PID (if no explicit API) is by iterating `SYS_GET_TASK_LIST` and finding own executable name.
   ; For simplicity here, let's use a dummy PID and assume the kill works.
   ; Actually, let's use current_pid as a unique identifier for the IPC, even if it's not the *OS PID*.
   mov eax, SYS_GET_TICK_COUNT ; A unique-enough ID for this instance
   mov [current_pid], eax      ; Store our instance's "PID" for the .pid file

   ; --- IPC: Check for existing instance ---
   ; Check if taskmgr.pid exists
   mov eax, SYS_GET_FILE_INFO
   mov ebx, PID_FILE_NAME
   int 0x40
   cmp eax, 0 ; If EAX is 0, file doesn't exist or is empty
   je .no_other_instance_found

   ; If file exists, read the PID from it
   push eax ; Save file size
   mov eax, SYS_READ_FILE
   mov ebx, PID_FILE_NAME
   mov ecx, old_pid_buffer
   mov edx, 4 ; Read 4 bytes (size of PID)
   int 0x40
   cmp ecx, 4 ; Check if 4 bytes (a PID) were read
   jne .pid_file_corrupt_or_empty ; Not 4 bytes, treat as no other instance

   mov edx, [old_pid_buffer] ; EDX = PID of the potentially running old instance
   cmp edx, [current_pid]    ; Is it our own unique ID? (Shouldn't happen)
   je .no_other_instance_found ; If it's our own ID, means previous launch failed to clear PID file or we are somehow relaunching ourselves.

   ; Attempt to kill the old instance using the PID from the file
   mov eax, SYS_KILL_TASK
   mov ebx, edx ; Kill the PID read from file
   int 0x40

   ; Give some time for the old instance to terminate
   ; This is a simple delay. A more robust check would involve polling SYS_GET_TASK_LIST.
   mov eax, SYS_GET_TICK_COUNT
   int 0x40
   add eax, 100 ; Wait for 100 milliseconds
   mov ecx, eax
.wait_for_kill_loop:
   mov eax, SYS_GET_TICK_COUNT
   cmp eax, ecx
   jl .wait_for_kill_loop ; Loop until 100ms passed

   jmp .become_primary_instance ; Proceed as primary

.pid_file_corrupt_or_empty:
   ; For simplicity, if PID file is corrupt/empty, delete it and proceed.
   mov eax, SYS_DELETE_FILE
   mov ebx, PID_FILE_NAME
   int 0x40
.no_other_instance_found:
   ; No other active instance found, or old one was successfully killed/cleaned up.
   ; This instance becomes the primary.

.become_primary_instance:
   ; Write our current_pid (our unique instance ID) to taskmgr.pid
   mov eax, SYS_CREATE_FILE
   mov ebx, PID_FILE_NAME
   int 0x40
   push eax ; Save file handle
   mov ebx, eax ; EBX = file handle
   mov ecx, current_pid ; ECX = pointer to our internal "PID"
   mov edx, 4 ; Write 4 bytes
   mov eax, SYS_WRITE_FILE
   int 0x40
   pop ebx ; Get file handle back
   mov eax, SYS_CLOSE_FILE
   int 0x40

   ; --- Restore state from taskmgr.state ---
   mov eax, SYS_GET_FILE_INFO
   mov ebx, STATE_FILE_NAME
   int 0x40
   cmp eax, 0 ; If EAX is 0, file doesn't exist or is empty
   je .no_state_file_found

   cmp eax, STATE_FILE_SIZE ; Check if file size matches expected state size
   jne .no_state_file_found ; If not, probably corrupt, ignore

   mov eax, SYS_READ_FILE
   mov ebx, STATE_FILE_NAME
   mov ecx, state_data_buffer
   mov edx, STATE_FILE_SIZE
   int 0x40
   cmp ecx, STATE_FILE_SIZE ; Check if all bytes were read
   jne .no_state_file_found

   ; If successful, load the state
   mov edx, [state_data_buffer + 0]  ; themeFlag
   mov [themeFlag], edx
   mov edx, [state_data_buffer + 4]  ; sortColumn
   mov [sortColumn], edx
   mov edx, [state_data_buffer + 8]  ; sortAscending
   mov [sortAscending], edx
   mov edx, [state_data_buffer + 12] ; logPosition
   mov [logPosition], edx

   jmp .continue_app_startup

.no_state_file_found:
   ; Use default initial values (already set at beginning of _start)

.continue_app_startup:
   ; Record app start time for calculating application uptime
   mov eax, SYS_GET_TICK_COUNT
   int 0x40
   mov [app_start_tick], eax

   ; --- Create Main Window ---
   mov eax, SYS_CREATE_WINDOW
   xor ebx, ebx
   mov ecx, windowTitle
   mov edx, windowClass
   mov esi, 50
   mov edi, 50
   mov ebp, 1024
   push dword 768
   push dword ADV_TASKMGR_WIN_STYLE
   int 0x40
   add esp, 8
   mov [mainWindow], eax

   ; --- Draw initial main window background panels ---
   call draw_main_window_background

   ; --- Create "Processes" Navigation Button ---
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [mainWindow]
   mov ecx, processesTabBtnText
   mov edx, 20
   mov esi, 20
   mov edi, 110
   mov ebp, 30
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov [processesTabButton], eax

   ; --- Create "Performance" Navigation Button ---
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [mainWindow]
   mov ecx, performanceTabBtnText
   mov edx, 20
   mov esi, 60
   mov edi, 110
   mov ebp, 30
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov [performanceTabButton], eax

   ; --- Create "System Info" Navigation Button ---
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [mainWindow]
   mov ecx, systemInfoTabBtnText
   mov edx, 20
   mov esi, 100
   mov edi, 110
   mov ebp, 30
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov [systemInfoTabButton], eax

   ; --- Create "About" Navigation Button ---
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [mainWindow]
   mov ecx, aboutButtonText
   mov edx, 20
   mov esi, 140
   mov edi, 110
   mov ebp, 30
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov [aboutButton], eax

   ; --- Create "Run in Background" Toggle Button ---
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [mainWindow]
   mov ecx, runBackgroundBtnText
   mov edx, 20
   mov esi, 180
   mov edi, 110
   mov ebp, 30
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov [runBackgroundButton], eax

   ; --- Create "View Log" Button --- (NEW)
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [mainWindow]
   mov ecx, viewLogButtonText
   mov edx, 20                     ; X in navigation panel
   mov esi, 220                    ; Y (below Run in Background)
   mov edi, 110
   mov ebp, 30
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov [viewLogButton], eax

   ; --- Create "Refresh" Button (Action button) ---
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [mainWindow]
   mov ecx, refreshText
   mov edx, MAIN_WIN_NAV_WIDTH + 10
   mov esi, 15
   mov edi, 100
   mov ebp, 25
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov [refreshButton], eax

   ; --- Create "Kill Process" Button (Action button) ---
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [mainWindow]
   mov ecx, killText
   mov edx, MAIN_WIN_NAV_WIDTH + 120
   mov esi, 15
   mov edi, 120
   mov ebp, 25
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov [killButton], eax

   ; --- Create "Theme" Button (Action button) ---
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [mainWindow]
   mov ecx, themeText
   mov edx, MAIN_WIN_NAV_WIDTH + 260
   mov esi, 15
   mov edi, 100
   mov ebp, 25
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov [themeButton], eax

   ; --- Create Search Edit Control ---
   mov eax, SYS_CREATE_EDIT
   mov ebx, [mainWindow]
   mov ecx, searchEditBuffer
   mov edx, MAIN_WIN_NAV_WIDTH + 380
   mov esi, 15
   mov edi, 200
   mov ebp, 25
   push dword EDIT_STYLE
   int 0x40
   add esp, 4
   mov [searchEdit], eax

   ; --- Create Multi-Column ListView ---
   mov eax, SYS_CREATE_LISTVIEW
   mov ebx, [mainWindow]
   xor ecx, ecx
   mov edx, MAIN_WIN_CONTENT_X + 10
   mov esi, MAIN_WIN_CONTENT_Y + 10
   mov edi, MAIN_WIN_CONTENT_WIDTH - 20
   mov ebp, MAIN_WIN_CONTENT_HEIGHT - 20
   push dword LISTVIEW_STYLE
   int 0x40
   add esp, 4
   mov [listView], eax

   ; --- Create System Stats Label ---
   mov eax, SYS_CREATE_LABEL
   mov ebx, [mainWindow]
   mov ecx, sysStatsInit
   mov edx, MAIN_WIN_NAV_WIDTH + 600
   mov esi, 15
   mov edi, 200
   mov ebp, 25
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   mov [sysStatsLabel], eax

   ; --- Set Up Auto-Refresh Timer (5000 ms) ---
   mov eax, SYS_SET_TIMER
   mov ebx, [mainWindow]
   push dword EVENT_TIMER_REFRESH
   push dword 5000
   int 0x40
   add esp, 8
   mov [timerHandle], eax

   ; Initial refresh to populate the process list
   jmp handle_refresh

event_loop:
   ; --- Main Event Loop ---
   mov eax, SYS_GET_EVENT
   int 0x40
   cmp eax, EVENT_REFRESH_BUTTON
   je handle_refresh
   cmp eax, EVENT_KILL_BUTTON
   je handle_kill
   cmp eax, EVENT_TIMER_REFRESH
   je handle_timer_refresh
   cmp eax, EVENT_EDIT_CHANGE
   je handle_edit_change
   cmp eax, EVENT_LISTVIEW_COLUMN_CLICK
   je handle_column_click
   cmp eax, EVENT_LISTVIEW_DBLCLICK
   je handle_listview_dblclick
   cmp eax, EVENT_KEY_F5
   je handle_refresh
   cmp eax, EVENT_KEY_DELETE
   je handle_kill
   cmp eax, EVENT_KEY_ENTER
   je handle_listview_dblclick
   cmp eax, EVENT_PERFORMANCE_BUTTON
   je handle_performance_page
   cmp eax, EVENT_KEY_T
   je handle_theme_toggle
   cmp eax, EVENT_CONTEXT_MENU
   je handle_context_menu
   cmp eax, EVENT_WINDOW_RESIZE
   je handle_window_resize
   cmp eax, EVENT_CLOSE_WINDOW
   je handle_close
   cmp eax, EVENT_SYSTEM_INFO_BUTTON
   je handle_system_info_page
   cmp eax, EVENT_ABOUT_BUTTON
   je handle_about_page
   cmp eax, EVENT_RUN_BACKGROUND_BUTTON
   je handle_run_background_toggle
   cmp eax, EVENT_VIEW_LOG_BUTTON       ; New handler for View Log button
   je handle_view_log_page
   cmp eax, EVENT_PRIORITY_LOW          ; New handlers for priority dialog
   je handle_priority_dialog_choice
   cmp eax, EVENT_PRIORITY_NORMAL
   je handle_priority_dialog_choice
   cmp eax, EVENT_PRIORITY_HIGH
   je handle_priority_dialog_choice
   cmp eax, EVENT_PRIORITY_REALTIME
   je handle_priority_dialog_choice
   cmp eax, EVENT_PRIORITY_APPLY
   je handle_priority_dialog_apply
   cmp eax, EVENT_PRIORITY_CANCEL
   je handle_priority_dialog_cancel
   cmp eax, EVENT_SUSPEND_PROCESS       ; New handler for suspend
   je handle_suspend_process
   cmp eax, EVENT_RESUME_PROCESS        ; New handler for resume
   je handle_resume_process
   jmp event_loop

; --------------------------------------------------------------------
; Subroutine: draw_main_window_background
; Draws the custom background panels for the main window based on current theme.
; --------------------------------------------------------------------
draw_main_window_background:
   push eax
   push ebx
   push ecx
   push edx
   push esi
   push edi
   push ebp

   mov ebx, [mainWindow] ; Main window handle

   ; Determine theme colors
   mov eax, [themeFlag]
   cmp eax, 0 ; Light theme
   je .set_light_colors
.set_dark_colors:
   mov ecx_nav_color, DARK_THEME_NAV_COLOR
   mov ecx_header_color, DARK_THEME_HEADER_COLOR
   mov ecx_content_color, DARK_THEME_CONTENT_COLOR
   mov ecx_border_color, DARK_THEME_BORDER_COLOR
   jmp .draw_panels
.set_light_colors:
   mov ecx_nav_color, LIGHT_THEME_NAV_COLOR
   mov ecx_header_color, LIGHT_THEME_HEADER_COLOR
   mov ecx_content_color, LIGHT_THEME_CONTENT_COLOR
   mov ecx_border_color, LIGHT_THEME_BORDER_COLOR

.draw_panels:
   ; Draw Header Panel (top)
   mov eax, SYS_DRAW_RECT
   ; ebx (window handle) is already set
   mov ecx, 0                          ; X
   mov edx, 0                          ; Y
   mov esi, 1024                       ; Width (full window)
   mov edi, MAIN_WIN_HEADER_HEIGHT     ; Height
   push dword [ecx_header_color]
   int 0x40
   add esp, 4

   ; Draw Navigation Panel (left)
   mov eax, SYS_DRAW_RECT
   ; ebx (window handle) is already set
   mov ecx, 0                          ; X
   mov edx, MAIN_WIN_HEADER_HEIGHT     ; Y (below header)
   mov esi, MAIN_WIN_NAV_WIDTH         ; Width
   mov edi, 768 - MAIN_WIN_HEADER_HEIGHT ; Height (rest of window height)
   push dword [ecx_nav_color]
   int 0x40
   add esp, 4

   ; Draw Main Content Panel (right)
   mov eax, SYS_DRAW_RECT
   ; ebx (window handle) is already set
   mov ecx, MAIN_WIN_NAV_WIDTH         ; X (right of nav panel)
   mov edx, MAIN_WIN_HEADER_HEIGHT     ; Y (below header)
   mov esi, 1024 - MAIN_WIN_NAV_WIDTH  ; Width
   mov edi, 768 - MAIN_WIN_HEADER_HEIGHT ; Height
   push dword [ecx_content_color]
   int 0x40
   add esp, 4

   ; Draw thin separator line between header and content
   mov eax, SYS_DRAW_RECT
   mov ecx, 0
   mov edx, MAIN_WIN_HEADER_HEIGHT - 1 ; Just above content
   mov esi, 1024
   mov edi, 1 ; Height of line
   push dword [ecx_border_color]
   int 0x40
   add esp, 4

   ; Draw thin separator line between nav and main content
   mov eax, SYS_DRAW_RECT
   mov ecx, MAIN_WIN_NAV_WIDTH - 1
   mov edx, MAIN_WIN_HEADER_HEIGHT ; Below header
   mov esi, 1 ; Width of line
   mov edi, 768 - MAIN_WIN_HEADER_HEIGHT
   push dword [ecx_border_color]
   int 0x40
   add esp, 4


   pop ebp
   pop edi
   pop esi
   pop edx
   pop ecx
   pop ebx
   pop eax
   ret

; --------------------------------------------------------------------
; Handler: Refresh Task List & Update System Stats (Updated for uptime tracking)
; --------------------------------------------------------------------
handle_refresh:
   ; Preserve original contents of taskBuffer for PID lookup later
   push ebx
   push ecx
   push esi
   push edi
   mov ecx, [task_count] ; Get current number of entries in our taskBuffer
   cmp ecx, 0
   je .skip_copy_old_buffer
   mov eax, OUR_TASK_ENTRY_SIZE
   mul ecx ; Calculate total bytes in current taskBuffer
   mov esi, taskBuffer ; Source: current taskBuffer
   mov edi, os_raw_task_list_buffer ; Destination: temp buffer for old data
   mov ecx, eax ; Set ECX for rep movsb (byte count)
   rep movsb
.skip_copy_old_buffer:
   pop edi
   pop esi
   pop ecx
   pop ebx

   ; --- Get NEW Raw Task List from OS ---
   mov eax, SYS_GET_TASK_LIST
   int 0x40
   mov esi, ebx ; ESI now points to the new raw TList buffer from OS
   mov edx, ecx ; EDX = number of new raw tasks
   mov [os_raw_task_count], edx

   ; Prepare for building the new, updated taskBuffer
   xor ebx, ebx ; EBX will be index for new_task_buffer (0 for now, used to increment task_count)
   mov dword [task_count], 0 ; Reset overall task count (will rebuild)

   ; Get current tick count for new processes
   mov eax, SYS_GET_TICK_COUNT
   int 0x40
   mov ecx_current_tick, eax ; Store current tick count globally or in temporary var

   ; Iterate through NEW raw OS tasks fetched from SYS_GET_TASK_LIST
   xor esi_new_task_idx, esi_new_task_idx ; Index for os_raw_task_list_buffer
.process_new_raw_tasks_loop:
   cmp esi_new_task_idx, [os_raw_task_count]
   jge .done_processing_new_raw_tasks

   ; Calculate pointer to current raw OS task entry
   mov edi_raw_task_ptr, esi_new_task_idx
   imul edi_raw_task_ptr, OS_TLIST_ENTRY_SIZE
   add edi_raw_task_ptr, esi ; ESI (base of OS raw buffer) + offset

   ; Get PID of current raw OS task
   mov edx_raw_pid, [edi_raw_task_ptr + 0] ; PID is at offset 0 in OS TList

   ; --- Search OLD taskBuffer (now in os_raw_task_list_buffer) for this PID ---
   push ecx_current_tick ; Save current tick on stack
   push edx_raw_pid      ; PID to search for on stack
   call find_pid_in_old_task_buffer ; Returns EAX = 1 if found (and sets found_pid_tick), 0 if not found
   pop edx_raw_pid       ; Restore PID
   pop ecx_current_tick  ; Restore current tick

   cmp eax, 1 ; Was PID found in old buffer?
   je .pid_found_in_old_buffer

   ; PID NOT found (this is a new process), set its observed_start_tick to current tick
   mov eax, ecx_current_tick ; Current tick count from when refresh started
   jmp .store_observed_tick

.pid_found_in_old_buffer:
   ; PID found, use its existing observed_start_tick retrieved by find_pid_in_old_task_buffer
   mov eax, [found_pid_tick]

.store_observed_tick:
   ; Copy raw OS task data and set observed_start_tick into our main taskBuffer
   mov edi_our_task_ptr, [task_count] ; Get current entry index for our taskBuffer
   imul edi_our_task_ptr, OUR_TASK_ENTRY_SIZE ; Convert to byte offset
   add edi_our_task_ptr, taskBuffer ; Pointer to destination in our taskBuffer

   ; Copy OS_TLIST_ENTRY_SIZE bytes of raw OS data (PID to Name Pointer)
   push esi_new_task_idx ; Save current outer loop counter
   push eax              ; Save observed_start_tick value (it's in EAX from above)
   mov ecx, OS_TLIST_ENTRY_SIZE ; Bytes to copy
   mov esi, edi_raw_task_ptr    ; Source (raw OS entry)
   mov edi, edi_our_task_ptr    ; Destination (our new entry)
   rep movsb
   pop eax               ; Restore observed_start_tick to EAX
   pop esi_new_task_idx  ; Restore outer loop counter

   ; Store the observed_start_tick at the end of our new entry
   mov dword [edi_our_task_ptr + OS_TLIST_ENTRY_SIZE], eax ; Store at offset 24

   inc dword [task_count] ; Increment our total task count for the next entry

   inc esi_new_task_idx ; Move to next new raw OS task
   jmp .process_new_raw_tasks_loop

.done_processing_new_raw_tasks:
   ; Clear the ListView before repopulating with the updated data
   mov eax, SYS_CLEAR_LISTVIEW
   mov ebx, [listView]
   int 0x40

   ; Now populate ListView from our updated and sorted taskBuffer.
   mov ecx, [task_count] ; Get final count of tasks in our buffer
   cmp ecx, 0
   je .done_populate ; Skip sorting and populating if no tasks

   push ecx
   call sort_tasks   ; Sort our taskBuffer containing extended data
   pop ecx

   mov edi, taskBuffer ; Start from the beginning of our sorted taskBuffer
.populate_loop:
   cmp ecx, 0
   je .done_populate
   ; Each OUR_TASK_ENTRY_SIZE record is 28 bytes.
   ; Our structure: PID (0), Mem (12), CPU (16), Name (20), Observed Tick (24)
   ; ListView Add Item expects: ListView handle, PID, Name, CPU, Mem
   mov eax, [edi+0]      ; TaskID (PID) at offset 0
   push eax
   mov eax, [edi+20]     ; Process name pointer at offset 20
   push eax
   mov eax, [edi+16]     ; CPU usage at offset 16
   push eax
   mov eax, [edi+12]     ; Memory usage (4KB pages) at offset 12
   imul eax, 4           ; Convert 4KB pages to KB (EAX = EAX * 4)
   push eax
   push dword [listView]
   mov eax, SYS_LISTVIEW_ADD_ITEM
   int 0x40
   add esp, 20 ; Clean up 5 pushed dwords (5 * 4 bytes)
   add edi, OUR_TASK_ENTRY_SIZE ; Move to next OUR_TASK_ENTRY_SIZE entry in our buffer
   dec ecx
   jmp .populate_loop
.done_populate:
   call update_system_stats
   call log_event_refresh
   jmp event_loop

; --------------------------------------------------------------------
; Subroutine: find_pid_in_old_task_buffer
; Searches the old taskBuffer (copied to os_raw_task_list_buffer as temp) for a given PID.
; Expects PID on stack.
; Returns: EAX = 1 if found (found_pid_tick is set), 0 if not found.
; --------------------------------------------------------------------
find_pid_in_old_task_buffer:
   push ebx
   push ecx
   push esi
   push edi

   mov ebx, [esp+20] ; Get PID from stack (skip saved registers and return address)
   mov ecx, [task_count] ; Number of tasks in the OLD buffer (from before refresh)
   mov esi, os_raw_task_list_buffer ; Pointer to the OLD taskBuffer (now in temp storage)

   xor eax, eax ; Assume not found (EAX=0)
   xor edi, edi ; Loop index

.find_loop:
   cmp edi, ecx
   jge .not_found_exit ; If index >= count, not found

   mov edx, [esi + edi*OUR_TASK_ENTRY_SIZE + 0] ; Get PID from current old task entry
   cmp edx, ebx ; Compare with target PID
   je .found_pid ; If match, jump

   inc edi
   jmp .find_loop

.found_pid:
   mov eax, 1 ; Set EAX to 1 (found)
   mov edx, [esi + edi*OUR_TASK_ENTRY_SIZE + OS_TLIST_ENTRY_SIZE] ; Get observed_start_tick
   mov [found_pid_tick], edx ; Store it in global variable
   jmp .exit_find

.not_found_exit:
   xor eax, eax ; Ensure EAX is 0 (not found)

.exit_find:
   pop edi
   pop esi
   pop ecx
   pop ebx
   ret 4 ; Clean up pushed PID


; --------------------------------------------------------------------
; Handler: Kill Selected Process
; --------------------------------------------------------------------
handle_kill:
   mov eax, SYS_GET_SELECTED_ITEM
   mov ebx, [listView]
   int 0x40
   cmp eax, -1
   je event_loop
   push eax
   call log_event_kill
   mov edx, eax
   mov eax, SYS_KILL_TASK
   int 0x40
   jmp handle_refresh

; --------------------------------------------------------------------
; Handler: Timer-based Auto-Refresh
; --------------------------------------------------------------------
handle_timer_refresh:
   jmp handle_refresh

; --------------------------------------------------------------------
; Handler: Edit Change (Filtering)
; --------------------------------------------------------------------
handle_edit_change:
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Column Header Click (Sorting)
; --------------------------------------------------------------------
handle_column_click:
   cmp eax, [sortColumn]
   jne .new_sort_column
   cmp dword [sortAscending], 1
   je .set_descending
   mov dword [sortAscending], 1
   jmp handle_refresh
.set_descending:
   mov dword [sortAscending], 0
   jmp handle_refresh
.new_sort_column:
   mov [sortColumn], eax
   mov dword [sortAscending], 1
   jmp handle_refresh

; --------------------------------------------------------------------
; Handler: ListView Double-Click (Process Details)
; --------------------------------------------------------------------
handle_listview_dblclick:
   mov eax, SYS_GET_SELECTED_ITEM
   mov ebx, [listView]
   int 0x40
   cmp eax, -1
   je event_loop
   
   ; Calculate pointer to selected task in OUR taskBuffer
   mov ecx, eax            ; ECX = selected index
   imul ecx, OUR_TASK_ENTRY_SIZE ; ECX = byte offset
   add ecx, taskBuffer     ; ECX = pointer to selected task in our buffer

   ; Pass the pointer to update_detail_ui
   push ecx                ; Push pointer to selected task's data
   call update_detail_ui
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Performance Page
; --------------------------------------------------------------------
handle_performance_page:
   ; Close other open 'pages'
   cmp dword [detailWindow], 0
   je .skip_close_detail
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [detailWindow]
   int 0x40
   mov dword [detailWindow], 0
.skip_close_detail:
   cmp dword [systemInfoWindow], 0
   je .skip_close_sysinfo
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [systemInfoWindow]
   int 0x40
   mov dword [systemInfoWindow], 0
.skip_close_sysinfo:
   cmp dword [aboutWindow], 0
   je .skip_close_about
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [aboutWindow]
   int 0x40
   mov dword [aboutWindow], 0
.skip_close_about:
   cmp dword [logViewerWindow], 0 ; New: Close Log Viewer
   je .skip_close_logviewer
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [logViewerWindow]
   int 0x40
   mov dword [logViewerWindow], 0
.skip_close_logviewer:
   cmp dword [priorityDialog], 0 ; New: Close Priority Dialog
   je .skip_close_priority_dialog
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [priorityDialog]
   int 0x40
   mov dword [priorityDialog], 0
.skip_close_priority_dialog:

   cmp dword [perfWindow], 0
   jne .update_perf
   mov eax, SYS_CREATE_WINDOW
   mov ebx, [mainWindow]
   mov ecx, perfTitle
   mov edx, perfClass
   mov esi_win_x, 150
   mov edi_win_y, 150
   mov ebp, 500
   push dword 400
   push dword ADV_TASKMGR_WIN_STYLE
   int 0x40
   add esp, 8
   mov [perfWindow], eax
.update_perf:
   call update_performance_page
   jmp event_loop

; --------------------------------------------------------------------
; Handler: System Information Page
; --------------------------------------------------------------------
handle_system_info_page:
   ; Close other open 'pages'
   cmp dword [detailWindow], 0
   je .skip_close_detail_sys
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [detailWindow]
   int 0x40
   mov dword [detailWindow], 0
.skip_close_detail_sys:
   cmp dword [perfWindow], 0
   je .skip_close_perf_sys
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [perfWindow]
   int 0x40
   mov dword [perfWindow], 0
.skip_close_perf_sys:
   cmp dword [aboutWindow], 0
   je .skip_close_about_sys
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [aboutWindow]
   int 0x40
   mov dword [aboutWindow], 0
.skip_close_about_sys:
   cmp dword [logViewerWindow], 0 ; New: Close Log Viewer
   je .skip_close_logviewer_sys
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [logViewerWindow]
   int 0x40
   mov dword [logViewerWindow], 0
.skip_close_logviewer_sys:
   cmp dword [priorityDialog], 0 ; New: Close Priority Dialog
   je .skip_close_priority_dialog_sys
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [priorityDialog]
   int 0x40
   mov dword [priorityDialog], 0
.skip_close_priority_dialog_sys:

   cmp dword [systemInfoWindow], 0
   jne .update_sys_info_dynamic
   mov eax, SYS_CREATE_WINDOW
   mov ebx, [mainWindow]
   mov ecx, systemInfoTitle
   mov edx, systemInfoClass
   mov esi_win_x, 150
   mov edi_win_y, 150
   mov ebp, 500
   push dword 300
   push dword ADV_TASKMGR_WIN_STYLE
   int 0x40
   add esp, 8
   mov [systemInfoWindow], eax
   call build_system_info_ui ; Build static UI elements
.update_sys_info_dynamic:
   call update_system_info_ui_dynamic ; Update dynamic elements (like uptime)
   jmp event_loop

; --------------------------------------------------------------------
; Handler: About Page
; --------------------------------------------------------------------
handle_about_page:
   ; Close other open 'pages'
   cmp dword [detailWindow], 0
   je .skip_close_detail_about
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [detailWindow]
   int 0x40
   mov dword [detailWindow], 0
.skip_close_detail_about:
   cmp dword [perfWindow], 0
   je .skip_close_perf_about
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [perfWindow]
   int 0x40
   mov dword [perfWindow], 0
.skip_close_perf_about:
   cmp dword [systemInfoWindow], 0
   je .skip_close_sysinfo_about
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [systemInfoWindow]
   int 0x40
   mov dword [systemInfoWindow], 0
.skip_close_sysinfo_about:
   cmp dword [logViewerWindow], 0 ; New: Close Log Viewer
   je .skip_close_logviewer_about
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [logViewerWindow]
   int 0x40
   mov dword [logViewerWindow], 0
.skip_close_logviewer_about:
   cmp dword [priorityDialog], 0 ; New: Close Priority Dialog
   je .skip_close_priority_dialog_about
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [priorityDialog]
   int 0x40
   mov dword [priorityDialog], 0
.skip_close_priority_dialog_about:

   cmp dword [aboutWindow], 0
   jne .update_about
   mov eax, SYS_CREATE_WINDOW
   mov ebx, [mainWindow]
   mov ecx, aboutTitle
   mov edx, aboutClass
   mov esi_win_x, 150
   mov edi_win_y, 150
   mov ebp, 400
   push dword 280
   push dword ADV_TASKMGR_WIN_STYLE
   int 0x40
   add esp, 8
   mov [aboutWindow], eax
   call build_about_ui ; Build static UI elements for About page
.update_about:
   jmp event_loop

; --------------------------------------------------------------------
; Handler: View Log Page (NEW)
; --------------------------------------------------------------------
handle_view_log_page:
   ; Close other open 'pages'
   cmp dword [detailWindow], 0
   je .skip_close_detail_log
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [detailWindow]
   int 0x40
   mov dword [detailWindow], 0
.skip_close_detail_log:
   cmp dword [perfWindow], 0
   je .skip_close_perf_log
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [perfWindow]
   int 0x40
   mov dword [perfWindow], 0
.skip_close_perf_log:
   cmp dword [systemInfoWindow], 0
   je .skip_close_sysinfo_log
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [systemInfoWindow]
   int 0x40
   mov dword [systemInfoWindow], 0
.skip_close_sysinfo_log:
   cmp dword [aboutWindow], 0
   je .skip_close_about_log
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [aboutWindow]
   int 0x40
   mov dword [aboutWindow], 0
.skip_close_about_log:
   cmp dword [priorityDialog], 0 ; New: Close Priority Dialog
   je .skip_close_priority_dialog_log
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [priorityDialog]
   int 0x40
   mov dword [priorityDialog], 0
.skip_close_priority_dialog_log:

   cmp dword [logViewerWindow], 0
   jne .update_log_viewer
   mov eax, SYS_CREATE_WINDOW
   mov ebx, [mainWindow]
   mov ecx, logViewerTitle
   mov edx, logViewerClass
   mov esi_win_x, 150
   mov edi_win_y, 150
   mov ebp, 600 ; Wider for log content
   push dword 400
   push dword ADV_TASKMGR_WIN_STYLE
   int 0x40
   add esp, 8
   mov [logViewerWindow], eax
   call build_log_viewer_ui ; Build UI for the first time (and load content)
.update_log_viewer:
   call update_log_viewer_content ; Reload content (if log file changed)
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Run in Background Toggle
; --------------------------------------------------------------------
handle_run_background_toggle:
   mov eax, [background_mode_active]
   cmp eax, 0
   je .set_background_on
   mov dword [background_mode_active], 0 ; Turn background mode OFF
   jmp event_loop
.set_background_on:
   mov dword [background_mode_active], 1 ; Turn background mode ON
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Set Priority Context Menu -> Open Dialog
; --------------------------------------------------------------------
handle_set_priority:
   mov eax, SYS_GET_SELECTED_ITEM
   mov ebx, [listView]
   int 0x40
   cmp eax, -1
   je event_loop ; No item selected

   ; Get PID of the selected process
   mov ecx, eax            ; ECX = selected index
   imul ecx, OUR_TASK_ENTRY_SIZE ; ECX = byte offset
   add ecx, taskBuffer     ; ECX = pointer to selected task in our buffer
   mov edx, [ecx]          ; EDX = PID of selected process
   mov [priority_dialog_pid], edx ; Store PID for the dialog

   ; Close other info windows first before opening dialog
   cmp dword [detailWindow], 0
   je .skip_close_detail_prio
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [detailWindow]
   int 0x40
   mov dword [detailWindow], 0
.skip_close_detail_prio:
   cmp dword [perfWindow], 0
   je .skip_close_perf_prio
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [perfWindow]
   int 0x40
   mov dword [perfWindow], 0
.skip_close_perf_prio:
   cmp dword [systemInfoWindow], 0
   je .skip_close_sysinfo_prio
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [systemInfoWindow]
   int 0x40
   mov dword [systemInfoWindow], 0
.skip_close_sysinfo_prio:
   cmp dword [aboutWindow], 0
   je .skip_close_about_prio
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [aboutWindow]
   int 0x40
   mov dword [aboutWindow], 0
.skip_close_about_prio:
   cmp dword [logViewerWindow], 0
   je .skip_close_logviewer_prio
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [logViewerWindow]
   int 0x40
   mov dword [logViewerWindow], 0
.skip_close_logviewer_prio:

   ; Create and open priority dialog
   cmp dword [priorityDialog], 0
   jne .update_priority_dialog ; If already open, just make sure it's focused
   mov eax, SYS_CREATE_WINDOW
   mov ebx, [mainWindow]
   mov ecx, priorityDialogTitle
   mov edx, priorityDialogClass
   mov esi_win_x, 200
   mov edi_win_y, 200
   mov ebp, 350 ; Width
   push dword 250 ; Height
   push dword ADV_TASKMGR_WIN_STYLE
   int 0x40
   add esp, 8
   mov [priorityDialog], eax
   call build_priority_dialog ; Build dialog UI
.update_priority_dialog:
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Priority Dialog Button Choices (Low, Normal, High, Realtime)
; --------------------------------------------------------------------
handle_priority_dialog_choice:
   ; EAX holds the event ID (1030 for Low, 1031 for Normal, etc.)
   sub eax, EVENT_PRIORITY_LOW ; Subtract base to get priority level (0, 1, 2, 3)
   mov [priority_level_selected], eax ; Store selected priority
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Priority Dialog Apply Button
; --------------------------------------------------------------------
handle_priority_dialog_apply:
   mov eax, SYS_SET_TASK_PRIORITY
   mov ebx, [priority_dialog_pid]  ; PID from stored selection
   mov ecx, [priority_level_selected] ; Priority level (0-3)
   int 0x40
   call log_event_set_priority     ; Log the action (existing log routine)
   mov eax, SYS_CLOSE_WINDOW       ; Close dialog
   mov ebx, [priorityDialog]
   int 0x40
   mov dword [priorityDialog], 0
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Priority Dialog Cancel Button
; --------------------------------------------------------------------
handle_priority_dialog_cancel:
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [priorityDialog]
   int 0x40
   mov dword [priorityDialog], 0
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Suspend Process
; --------------------------------------------------------------------
handle_suspend_process:
   mov eax, SYS_GET_SELECTED_ITEM
   mov ebx, [listView]
   int 0x40
   cmp eax, -1
   je event_loop ; No item selected

   ; Get PID of the selected process
   mov ecx, eax
   imul ecx, OUR_TASK_ENTRY_SIZE
   add ecx, taskBuffer
   mov edx, [ecx] ; EDX = PID of selected process

   mov eax, SYS_PAUSE_TASK
   mov ebx, edx ; PID to suspend
   int 0x40
   ; Log this action if desired (e.g., call log_event_suspend)
   jmp handle_refresh ; Refresh list to show status change if OS updates it
   
; --------------------------------------------------------------------
; Handler: Resume Process
; --------------------------------------------------------------------
handle_resume_process:
   mov eax, SYS_GET_SELECTED_ITEM
   mov ebx, [listView]
   int 0x40
   cmp eax, -1
   je event_loop ; No item selected

   ; Get PID of the selected process
   mov ecx, eax
   imul ecx, OUR_TASK_ENTRY_SIZE
   add ecx, taskBuffer
   mov edx, [ecx] ; EDX = PID of selected process

   mov eax, SYS_RESUME_TASK
   mov ebx, edx ; PID to resume
   int 0x40
   ; Log this action if desired (e.g., call log_event_resume)
   jmp handle_refresh ; Refresh list to show status change if OS updates it


; --------------------------------------------------------------------
; Handler: Context Menu (Right-Click) on ListView
; --------------------------------------------------------------------
handle_context_menu:
   mov eax, SYS_SHOW_CONTEXT_MENU
   mov ebx, [mainWindow]
   mov ecx, ctx_menu_data
   int 0x40
   cmp eax, 1
   je handle_listview_dblclick
   cmp eax, 2
   je handle_kill
   cmp eax, 3
   je handle_set_priority
   cmp eax, 4
   je handle_suspend_process
   cmp eax, 5
   je handle_resume_process
   cmp eax, 6
   je handle_export_log
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Theme Toggle
; --------------------------------------------------------------------
handle_theme_toggle:
   mov eax, [themeFlag]
   cmp eax, 0
   je .set_dark_theme
   mov dword [themeFlag], 0 ; Set to light
   jmp .apply_theme
.set_dark_theme:
   mov dword [themeFlag], 1 ; Set to dark
.apply_theme:
   call draw_main_window_background ; Redraw custom backgrounds
   mov eax, SYS_ADJUST_CONTROLS     ; Adjust internal controls (might trigger button redraws)
   int 0x40
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Set Priority (Context Menu Option)
; --------------------------------------------------------------------
handle_set_priority:
   ; This handler is already defined above,
   ; it's called from context menu. No change here.
   jmp event_loop ; Fall through from context menu event.

; --------------------------------------------------------------------
; Handler: Export Log (Context Menu Option)
; --------------------------------------------------------------------
handle_export_log:
   mov eax, SYS_WRITE_FILE
   mov ebx, log_filename
   mov ecx, logBuffer
   mov edx, [logPosition]
   int 0x40
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Window Resize
; --------------------------------------------------------------------
handle_window_resize:
   call draw_main_window_background ; Redraw custom backgrounds on resize
   mov eax, SYS_ADJUST_CONTROLS     ; Adjust internal controls
   int 0x40
   cmp dword [perfWindow], 0        ; Redraw graph if performance window is active
   je .skip_perf_redraw
   call draw_graph
.skip_perf_redraw:
   cmp dword [systemInfoWindow], 0 ; Update system info (especially uptime)
   je .skip_sysinfo_redraw
   call update_system_info_ui_dynamic
.skip_sysinfo_redraw:
   cmp dword [logViewerWindow], 0 ; Re-display log content if log viewer is open
   je .skip_logviewer_redraw
   call update_log_viewer_content
.skip_logviewer_redraw:
   jmp event_loop

; --------------------------------------------------------------------
; Handler: Close Application
; --------------------------------------------------------------------
handle_close:
   ; Store current state to file
   mov edx, [themeFlag]
   mov [state_data_buffer + 0], edx
   mov edx, [sortColumn]
   mov [state_data_buffer + 4], edx
   mov edx, [sortAscending]
   mov [state_data_buffer + 8], edx
   mov edx, [logPosition]
   mov [state_data_buffer + 12], edx

   mov eax, SYS_CREATE_FILE
   mov ebx, STATE_FILE_NAME
   int 0x40
   push eax ; Save file handle
   mov ebx, eax ; EBX = file handle
   mov ecx, state_data_buffer
   mov edx, STATE_FILE_SIZE
   mov eax, SYS_WRITE_FILE
   int 0x40
   pop ebx ; Get file handle back
   mov eax, SYS_CLOSE_FILE
   int 0x40

   ; Close all auxiliary windows
   cmp dword [detailWindow], 0
   je .skip_close_detail_final
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [detailWindow]
   int 0x40
.skip_close_detail_final:
   cmp dword [perfWindow], 0
   je .skip_close_perf_final
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [perfWindow]
   int 0x40
.skip_close_perf_final:
   cmp dword [systemInfoWindow], 0
   je .skip_close_sysinfo_final
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [systemInfoWindow]
   int 0x40
.skip_close_sysinfo_final:
   cmp dword [aboutWindow], 0
   je .skip_close_about_final
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [aboutWindow]
   int 0x40
.skip_close_about_final:
   cmp dword [logViewerWindow], 0
   je .skip_close_logviewer_final
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [logViewerWindow]
   int 0x40
.skip_close_logviewer_final:
   cmp dword [priorityDialog], 0
   je .skip_close_priority_dialog_final
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [priorityDialog]
   int 0x40
.skip_close_priority_dialog_final:

   ; Check background mode flag
   mov eax, [background_mode_active]
   cmp eax, 1 ; If background mode is active
   je .keep_running_in_background

   ; If not in background mode, delete PID file, kill timer, close main window and exit app
   mov eax, SYS_DELETE_FILE
   mov ebx, PID_FILE_NAME
   int 0x40

   mov eax, SYS_KILL_TIMER
   mov ebx, [timerHandle]
   int 0x40
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [mainWindow]
   int 0x40
   mov eax, SYS_EXIT_APP
   int 0x40
   ; Should not reach here if SYS_EXIT_APP is called.

.keep_running_in_background:
   ; If in background mode, just close the main window and continue event loop
   ; The timer (timerHandle) remains active, and the event_loop keeps polling.
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [mainWindow]
   int 0x40
   mov dword [mainWindow], 0 ; Clear main window handle to indicate it's closed
   jmp event_loop


; --------------------------------------------------------------------
; Subroutine: update_detail_ui
; Creates/updates a Process Details window and populates it with details
; retrieved directly from our extended taskBuffer entry.
; Expects a pointer (on stack) to the selected OUR_TASK_ENTRY_SIZE entry.
; --------------------------------------------------------------------
update_detail_ui:
   pop esi               ; ESI -> selected OUR_TASK_ENTRY_SIZE entry in taskBuffer
   ; Close existing detail window if open
   cmp dword [detailWindow], 0
   je .create_new_detail_win
   mov eax, SYS_CLOSE_WINDOW
   mov ebx, [detailWindow]
   int 0x40
   mov dword [detailWindow], 0

.create_new_detail_win:
   mov eax, SYS_CREATE_WINDOW
   mov ebx, [mainWindow]
   mov ecx, detailTitle
   mov edx, 150
   mov esi_win_x, 150
   mov edi_win_y, 150
   mov ebp, 400
   push dword 250
   push dword ADV_TASKMGR_WIN_STYLE
   int 0x40
   add esp, 8
   mov [detailWindow], eax

   ; --- Populate Labels for Process Details ---
   ; ESI points to the selected OUR_TASK_ENTRY_SIZE structure.
   ; Our structure: PID (0), Mem (12), CPU (16), Name (20), Observed Tick (24)

   ; PID: (Offset 0)
   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, detailPIDText
   mov edx, 20
   mov esi_label, 50
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   mov eax, [esi+0] ; PID from OUR_TASK_ENTRY_SIZE
   mov edx, eax
   mov ecx, numbuf
   call itoa
   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, numbuf
   mov edx, 130
   mov esi_label, 50
   mov edi_label_w, 200
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Name: (Offset 20)
   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, detailNameText
   mov edx, 20
   mov esi_label, 80
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, [esi+20] ; Process Name pointer
   mov edx, 130
   mov esi_label, 80
   mov edi_label_w, 200
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; CPU Usage: (Offset 16)
   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, detailCPUText
   mov edx, 20
   mov esi_label, 110
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   mov eax, [esi+16] ; CPU usage
   mov edx, eax
   mov ecx, numbuf
   call itoa
   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, numbuf
   mov edx, 130
   mov esi_label, 110
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Memory Usage (KB): (Offset 12 - convert 4KB pages to KB)
   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, detailMemText
   mov edx, 20
   mov esi_label, 140
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   mov eax, [esi+12] ; Memory usage (4KB pages)
   imul eax, 4       ; Convert to KB
   mov edx, eax
   mov ecx, numbuf
   call itoa
   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, numbuf
   mov edx, 130
   mov esi_label, 140
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Process Uptime (s): (Offset 24 - observed_start_tick)
   ; Get current tick count
   mov eax, SYS_GET_TICK_COUNT
   int 0x40
   mov ebx, eax ; Current tick count in EBX

   mov ecx, [esi+24] ; Observed start tick from our task entry
   sub ebx, ecx ; Calculate difference (uptime in ms)
   xor edx, edx
   mov ecx, 1000 ; Divide by 1000 to get seconds
   div ecx       ; EAX = uptime in seconds

   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, detailUptimeText
   mov edx, 20
   mov esi_label, 170
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   mov edx, eax ; Uptime in seconds (from division)
   mov ecx, numbuf
   call itoa
   mov eax, SYS_CREATE_LABEL
   mov ebx, [detailWindow]
   mov ecx, numbuf
   mov edx, 130
   mov esi_label, 170
   mov edi_label_w, 200
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ret

; --------------------------------------------------------------------
; Subroutine: build_system_info_ui
; Creates System Information window, populating static elements.
; Dynamic elements (like uptime) are updated by update_system_info_ui_dynamic.
; --------------------------------------------------------------------
build_system_info_ui:
   ; Call SYS_GET_SYSTEM_INFO (50) for static info
   ; Returns EAX = Total RAM (MB), EBX = Pointer to Processor Type string.
   mov eax, SYS_GET_SYSTEM_INFO
   int 0x40
   push eax ; Save Total RAM (MB)
   push ebx ; Save Pointer to Processor Type string

   pop esi ; ESI -> Processor Type string (from EBX)
   pop edi ; EDI = Total RAM (MB) (from EAX)

   ; --- Populate Static Labels for System Info ---

   ; CPU Type:
   mov eax, SYS_CREATE_LABEL
   mov ebx, [systemInfoWindow]
   mov ecx, sysInfoCPUTypeText
   mov edx, 20
   mov esi_label, 50
   mov edi_label_w, 150
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   mov eax, SYS_CREATE_LABEL
   mov ebx, [systemInfoWindow]
   mov ecx, esi ; Processor Type string
   mov edx, 170
   mov esi_label, 50
   mov edi_label_w, 300
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Total RAM (MB):
   mov eax, SYS_CREATE_LABEL
   mov ebx, [systemInfoWindow]
   mov ecx, sysInfoRAMText
   mov edx, 20
   mov esi_label, 80
   mov edi_label_w, 150
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   mov eax, edi ; Total RAM (MB)
   mov edx, eax
   mov ecx, numbuf
   call itoa
   mov eax, SYS_CREATE_LABEL
   mov ebx, [systemInfoWindow]
   mov ecx, numbuf
   mov edx, 170
   mov esi_label, 80
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Create label for App Uptime (will be updated dynamically)
   mov eax, SYS_CREATE_LABEL
   mov ebx, [systemInfoWindow]
   mov ecx, sysInfoAppUptimeText
   mov edx, 20
   mov esi_label, 110
   mov edi_label_w, 150
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   ; Create a placeholder label for the actual uptime value
   mov eax, SYS_CREATE_LABEL
   mov ebx, [systemInfoWindow]
   mov ecx, "0" ; Initial value
   mov edx, 170
   mov esi_label, 110
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   mov [sysInfoAppUptimeLabel], eax ; Save handle to this label for dynamic updates

   ret

; --------------------------------------------------------------------
; Subroutine: update_system_info_ui_dynamic
; Updates the dynamic elements of the System Information window (e.g., App Uptime).
; Called on refreshes or window resize if the System Info window is open.
; --------------------------------------------------------------------
update_system_info_ui_dynamic:
   ; Check if the system info window is actually open
   cmp dword [systemInfoWindow], 0
   je .exit_update_dynamic

   ; Calculate App Uptime
   mov eax, SYS_GET_TICK_COUNT
   int 0x40
   sub eax, [app_start_tick] ; Uptime in ms
   xor edx, edx
   mov ecx, 1000             ; Divide by 1000 to get seconds
   div ecx                   ; EAX = uptime in seconds

   ; Update the App Uptime label
   mov edx, eax ; Uptime in seconds
   mov ecx, numbuf
   call itoa
   mov eax, SYS_LABEL_SET_TEXT
   mov ebx, [sysInfoAppUptimeLabel] ; Use saved label handle
   mov ecx, numbuf
   int 0x40

.exit_update_dynamic:
   ret

; --------------------------------------------------------------------
; Subroutine: build_about_ui
; Creates the About window and populates it with program information.
; --------------------------------------------------------------------
build_about_ui:
   ; Developer Name
   mov eax, SYS_CREATE_LABEL
   mov ebx, [aboutWindow]
   mov ecx, devNameText
   mov edx, 20
   mov esi_label, 30
   mov edi_label_w, 350
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Program Name
   mov eax, SYS_CREATE_LABEL
   mov ebx, [aboutWindow]
   mov ecx, programNameText
   mov edx, 20
   mov esi_label, 55
   mov edi_label_w, 350
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Version
   mov eax, SYS_CREATE_LABEL
   mov ebx, [aboutWindow]
   mov ecx, versionText
   mov edx, 20
   mov esi_label, 80
   mov edi_label_w, 350
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Date
   mov eax, SYS_CREATE_LABEL
   mov ebx, [aboutWindow]
   mov ecx, releaseDateText
   mov edx, 20
   mov esi_label, 105
   mov edi_label_w, 350
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; OS Info
   mov eax, SYS_CREATE_LABEL
   mov ebx, [aboutWindow]
   mov ecx, osInfoText
   mov edx, 20
   mov esi_label, 130
   mov edi_label_w, 350
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Background Info (new section - multi-line)
   mov eax, SYS_CREATE_LABEL
   mov ebx, [aboutWindow]
   mov ecx, aboutBackgroundInfo
   mov edx, 20
   mov esi_label, 160 ; Position below OS Info
   mov edi_label_w, 360 ; Wider to fit sentence
   mov ebp_label_h, 50  ; Taller for multiple lines (approx)
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Autostart Info (new section - multi-line)
   mov eax, SYS_CREATE_LABEL
   mov ebx, [aboutWindow]
   mov ecx, aboutAutostartInfo
   mov edx, 20
   mov esi_label, 210 ; Position below background info
   mov edi_label_w, 360
   mov ebp_label_h, 40
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; IPC Info (new section - multi-line)
   mov eax, SYS_CREATE_LABEL
   mov ebx, [aboutWindow]
   mov ecx, aboutIPCInfo
   mov edx, 20
   mov esi_label, 250 ; Position below autostart info
   mov edi_label_w, 360
   mov ebp_label_h, 50
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ret

; --------------------------------------------------------------------
; Subroutine: build_log_viewer_ui (NEW)
; Creates the Log Viewer window and populates it with log content.
; --------------------------------------------------------------------
build_log_viewer_ui:
   ; Create a large label to display log content
   mov eax, SYS_CREATE_LABEL
   mov ebx, [logViewerWindow]
   mov ecx, "" ; Initial empty text
   mov edx, 10
   mov esi_label, 10
   mov edi_label_w, 580 ; Width
   mov ebp_label_h, 380 ; Height
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   mov [logViewerLabel], eax ; Save handle for content updates

   ; Initial content load (will also be called by update_log_viewer_content)
   call update_log_viewer_content
   ret

; --------------------------------------------------------------------
; Subroutine: update_log_viewer_content (NEW)
; Reads the log file and updates the log viewer label.
; --------------------------------------------------------------------
update_log_viewer_content:
   ; Check if log viewer window is open
   cmp dword [logViewerWindow], 0
   je .exit_update_log_viewer

   ; Get file info for log file
   mov eax, SYS_GET_FILE_INFO
   mov ebx, log_filename
   int 0x40
   mov esi, eax ; ESI = log file size
   cmp esi, 0
   je .empty_log_file ; No log file or empty

   cmp esi, 4096 ; Check if log file is larger than our buffer
   jg .log_file_too_large ; Cap at buffer size

   ; Read log file into logBuffer
   mov eax, SYS_READ_FILE
   mov ebx, log_filename
   mov ecx, logBuffer
   mov edx, esi ; Read 'esi' bytes (file size)
   int 0x40
   mov ebx, ecx ; EBX = bytes read (from SYS_READ_FILE)
   cmp ebx, 0 ; Check if anything was read
   jle .empty_log_file

   ; Null-terminate the buffer if it's smaller than full size
   cmp ebx, 4096
   jge .no_null_terminate_needed
   mov byte [logBuffer + ebx], 0 ; Null terminate after content
.no_null_terminate_needed:

   ; Set the label text
   mov eax, SYS_LABEL_SET_TEXT
   mov ebx, [logViewerLabel]
   mov ecx, logBuffer
   int 0x40
   jmp .exit_update_log_viewer

.log_file_too_large:
   ; Optionally display a message that log is too large
   mov eax, SYS_LABEL_SET_TEXT
   mov ebx, [logViewerLabel]
   mov ecx, "Log file too large to display. Export to view full log." ; Placeholder string
   int 0x40
   jmp .exit_update_log_viewer

.empty_log_file:
   mov eax, SYS_LABEL_SET_TEXT
   mov ebx, [logViewerLabel]
   mov ecx, "Log is empty." ; Placeholder string
   int 0x40

.exit_update_log_viewer:
   ret

; --------------------------------------------------------------------
; Subroutine: build_priority_dialog (NEW)
; Creates the Set Priority dialog.
; --------------------------------------------------------------------
build_priority_dialog:
   ; Display selected process name/PID
   mov eax, SYS_CREATE_LABEL
   mov ebx, [priorityDialog]
   mov ecx, priorityProcessLabel
   mov edx, 20
   mov esi_label, 30
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4
   
   ; Convert PID to string and display
   mov eax, [priority_dialog_pid]
   mov ecx, numbuf
   call itoa
   mov eax, SYS_CREATE_LABEL
   mov ebx, [priorityDialog]
   mov ecx, numbuf
   mov edx, 120
   mov esi_label, 30
   mov edi_label_w, 100
   mov ebp_label_h, 20
   push dword LABEL_STYLE
   int 0x40
   add esp, 4

   ; Priority Level Buttons (simulating radio buttons)
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [priorityDialog]
   mov ecx, priorityLevelLow
   mov edx, 20
   mov esi_label, 70
   mov edi_label_w, 120
   mov ebp_label_h, 25
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov edx, EVENT_PRIORITY_LOW ; Set its event ID

   mov eax, SYS_CREATE_BUTTON
   mov ebx, [priorityDialog]
   mov ecx, priorityLevelNormal
   mov edx, 20
   mov esi_label, 100
   mov edi_label_w, 120
   mov ebp_label_h, 25
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov edx, EVENT_PRIORITY_NORMAL

   mov eax, SYS_CREATE_BUTTON
   mov ebx, [priorityDialog]
   mov ecx, priorityLevelHigh
   mov edx, 20
   mov esi_label, 130
   mov edi_label_w, 120
   mov ebp_label_h, 25
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov edx, EVENT_PRIORITY_HIGH

   mov eax, SYS_CREATE_BUTTON
   mov ebx, [priorityDialog]
   mov ecx, priorityLevelRealtime
   mov edx, 20
   mov esi_label, 160
   mov edi_label_w, 120
   mov ebp_label_h, 25
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov edx, EVENT_PRIORITY_REALTIME

   ; Apply and Cancel Buttons
   mov eax, SYS_CREATE_BUTTON
   mov ebx, [priorityDialog]
   mov ecx, priorityApplyBtnText
   mov edx, 100
   mov esi_label, 200
   mov edi_label_w, 80
   mov ebp_label_h, 25
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov edx, EVENT_PRIORITY_APPLY

   mov eax, SYS_CREATE_BUTTON
   mov ebx, [priorityDialog]
   mov ecx, priorityCancelBtnText
   mov edx, 200
   mov esi_label, 200
   mov edi_label_w, 80
   mov ebp_label_h, 25
   push dword BUTTON_STYLE
   int 0x40
   add esp, 4
   mov edx, EVENT_PRIORITY_CANCEL

   ; Set default selected priority (Normal)
   mov dword [priority_level_selected], 1 ; Default to Normal (1)
   ret

; --------------------------------------------------------------------
; Subroutine: update_performance_page
; Updates the Performance window with real-time CPU load details and memory usage,
; and then calls draw_graph to render the graph.
; --------------------------------------------------------------------
update_performance_page:
   mov eax, SYS_GET_SYSTEM_STATS
   int 0x40
   mov [last_cpu], eax
   mov [last_mem], ebx
   mov ecx, [perfIndex]
   mov dword [perfBuffer + ecx*4], eax
   inc ecx
   cmp ecx, PERF_BUFFER_SIZE
   jl .store_ok
   mov ecx, 0
.store_ok:
   mov [perfIndex], ecx
   call calc_cpu_stats
   mov edi, perfStatsBuffer
   mov esi, cpu_label_str
   call strcpy_end
   mov eax, [last_cpu]
   mov ecx, numbuf
   call itoa
   mov esi, numbuf
   call strcat_end
   mov esi, percent_space_str
   call strcat_end
   mov esi, avg_label_str
   call strcat_end
   mov eax, eax
   mov ecx, numbuf
   call itoa
   mov esi, numbuf
   call strcat_end
   mov esi, percent_space_str
   call strcat_end
   mov esi, min_label_str
   call strcat_end
   mov eax, ebx
   mov ecx, numbuf
   call itoa
   mov esi, numbuf
   call strcat_end
   mov esi, percent_space_str
   call strcat_end
   mov esi, max_label_str
   call strcat_end
   mov eax, edx
   mov ecx, numbuf
   call itoa
   mov esi, numbuf
   call strcat_end
   mov esi, percent_space_str
   call strcat_end
   mov esi, mem_label_str
   call strcat_end
   mov eax, [last_mem]
   mov ecx, numbuf
   call itoa
   mov esi, numbuf
   call strcat_end
   mov esi, mb_label_str
   call strcat_end
   mov eax, SYS_LABEL_SET_TEXT
   mov ebx, [perfWindow]
   mov ecx, perfStatsBuffer
   int 0x40
   call draw_graph
   ret

; --------------------------------------------------------------------
; Subroutine: draw_graph
; Draws the CPU usage graph in the performance window using SYS_DRAW_RECT.
; For each sample in perfBuffer, a vertical bar is drawn.
; --------------------------------------------------------------------
draw_graph:
   push ebp
   push esi
   push edi
   push ebx

   mov ebp, [perfWindow]

   ; Clear the graph area first with content background color
   mov eax, SYS_DRAW_RECT
   mov ebx, ebp
   mov ecx, GRAPH_X
   mov edx, GRAPH_Y
   mov esi, GRAPH_WIDTH
   mov edi, GRAPH_HEIGHT
   mov edx_temp_color, [themeFlag] ; Get current theme flag
   cmp edx_temp_color, 0 ; Light theme
   je .set_light_graph_bg
   mov edx_temp_color, DARK_THEME_CONTENT_COLOR
   jmp .apply_graph_bg
.set_light_graph_bg:
   mov edx_temp_color, LIGHT_THEME_CONTENT_COLOR
.apply_graph_bg:
   push dword [edx_temp_color] ; Push background color
   int 0x40
   add esp, 4

   ; Draw 50% grid line (horizontal)
   mov eax, SYS_DRAW_RECT
   mov ebx, ebp
   mov ecx, GRAPH_X
   mov edx, GRAPH_Y + (GRAPH_HEIGHT / 2) ; Y at 50% mark
   mov esi, GRAPH_WIDTH
   mov edi, 1 ; Line height
   push dword GRID_LINE_COLOR
   int 0x40
   add esp, 4


   xor edi, edi ; loop index
.draw_loop:
   cmp edi, PERF_BUFFER_SIZE
   jge .done_draw
   mov eax, edi
   imul eax, SAMPLE_WIDTH
   add eax, GRAPH_X
   mov ecx, eax ; x coordinate
   mov eax, [perfBuffer + edi*4] ; Load sample value
   mov esi_height, GRAPH_HEIGHT ; Use esi_height for multiplication
   imul eax, esi_height
   xor edx, edx
   mov esi_div, 100 ; Use esi_div for divisor
   div esi_div
   cmp eax, GRAPH_HEIGHT
   jle .calc_y_graph
   mov eax, GRAPH_HEIGHT
.calc_y_graph:
   mov edi_temp, eax ; Save line_height
   mov eax, GRAPH_HEIGHT
   sub eax, edi_temp
   add eax, GRAPH_Y
   mov edx, eax ; y coordinate

   mov eax, SYS_DRAW_RECT
   mov ebx, ebp
   ; ECX = x, EDX = y, ESI = width, EDI = height
   mov esi, SAMPLE_WIDTH
   mov edi, edi_temp
   push dword GRAPH_BAR_COLOR ; Blue color for bars
   int 0x40
   add esp, 4
   inc edi
   jmp .draw_loop
.done_draw:
   pop ebx
   pop edi
   pop esi
   pop ebp
   ret


; --------------------------------------------------------------------
; Subroutine: calc_cpu_stats
; Computes average, minimum, and maximum CPU usage from the perfBuffer.
; Returns: EAX = average, EBX = minimum, EDX = maximum.
; --------------------------------------------------------------------
calc_cpu_stats:
   push ebx
   push ecx
   push esi
   push edi
   mov ecx, PERF_BUFFER_SIZE
   xor eax, eax
   mov ebx, 101 ; Initialize min to a value higher than any possible CPU usage
   xor edx, edx ; Initialize max to 0
   xor edi, edi ; Loop index
   
   ; Loop through the performance buffer
.loop_calc:
   cmp edi, ecx
   jge .calc_done ; Exit loop if index >= count
   
   mov esi, [perfBuffer + edi*4] ; Load current sample
   add eax, esi                  ; Add to sum (EAX)
   
   cmp esi, ebx                  ; Compare with current minimum
   jge .check_max                ; If sample is >= current min, go check max
   mov ebx, esi                  ; Otherwise, new minimum found
   
.check_max:
   cmp esi, edx                  ; Compare with current maximum
   jle .next_sample              ; If sample is <= current max, go to next sample
   mov edx, esi                  ; Otherwise, new maximum found
   
.next_sample:
   inc edi                       ; Increment loop index
   jmp .loop_calc
   
.calc_done:
   ; Calculate Average = sum / count
   mov esi, ecx                  ; ESI = count (PERF_BUFFER_SIZE)
   cmp esi, 0                    ; Avoid division by zero
   je .no_samples_div_zero       ; If count is zero, average remains 0 (from xor eax, eax)
   xor edx, edx                  ; Clear EDX for division
   div esi                       ; EAX = quotient (average)
.no_samples_div_zero:
   
   pop edi
   pop esi
   pop ecx
   pop ebx
   ret

; --------------------------------------------------------------------
; Subroutine: strcpy_end
; Copies a null-terminated string from source (ESI) to destination (EDI)
; and leaves EDI pointing just before the null terminator.
; --------------------------------------------------------------------
strcpy_end:
   cld
.copy_loop:
   lodsb
   stosb
   cmp al, 0
   jne .copy_loop
   dec edi
   ret

; --------------------------------------------------------------------
; Subroutine: strcat_end
; Appends a null-terminated string from source (ESI) to destination (EDI),
; leaving EDI just before the new null terminator.
; --------------------------------------------------------------------
strcat_end:
   cld
.find_end:
   cmp byte [edi], 0
   je .append_loop
   inc edi
   jmp .find_end
.append_loop:
   lodsb
   stosb
   cmp al, 0
   jne .append_loop
   dec edi
   ret

; --------------------------------------------------------------------
; Subroutine: strcmp
; Compares two null-terminated strings pointed to by ESI and EDI.
; Returns: EAX <0 if string1 < string2, 0 if equal, >0 if string1 > string2.
; --------------------------------------------------------------------
strcmp:
   push ebx
.compare_loop:
   lodsb
   mov bl, byte [edi]
   cmp al, bl
   jne .diff
   cmp al, 0
   je .equal
   inc edi
   jmp .compare_loop
.diff:
   sub al, bl
   movzx eax, al
   jmp .done
.equal:
   xor eax, eax
.done:
   pop ebx
   ret

; --------------------------------------------------------------------
; Subroutine: sort_tasks
; Sorts the array of task records in taskBuffer based on sortColumn and sortAscending.
; Uses bubble sort.
; --------------------------------------------------------------------
sort_tasks:
   push ebp
   push esi
   push edi
   push ebx
   push edx

   mov ebp, taskBuffer
   mov esi, 0
   mov ecx, [task_count]
   cmp ecx, 1
   jbe .done_sort

.outer_loop:
   cmp esi, ecx
   jge .outer_loop_done

   mov edi, 0
   mov ebx, ecx
   sub ebx, esi
   dec ebx
   cmp ebx, 0
   jle .inner_loop_done

.inner_loop:
   cmp edi, ebx
   jge .inner_loop_done

   ; Calculate addresses for current and next record
   mov eax_ptr, edi
   imul eax_ptr, OUR_TASK_ENTRY_SIZE
   add eax_ptr, ebp            ; Pointer to record j

   mov edx_ptr, eax_ptr
   add edx_ptr, OUR_TASK_ENTRY_SIZE ; Pointer to record j+1

   mov dword [sort_result], 0
   mov dword [temp_sort_col], [sortColumn]
   cmp dword [temp_sort_col], 0
   je .compare_name
   cmp dword [temp_sort_col], 1
   je .compare_taskid
   cmp dword [temp_sort_col], 2
   je .compare_cpu
   cmp dword [temp_sort_col], 3
   je .compare_mem
   jmp .skip_compare

.compare_name:
   ; Name is at offset 20 in our task entry
   mov esi_str, dword [eax_ptr+20]
   mov edi_str, dword [edx_ptr+20]
   call strcmp
   mov [sort_result], eax
   jmp .compare_result

.compare_taskid:
   ; PID is at offset 0 in our task entry
   mov eax_val, [eax_ptr+0]
   mov ebx_val, [edx_ptr+0]
   sub eax_val, ebx_val
   mov [sort_result], eax_val
   jmp .compare_result

.compare_cpu:
   ; CPU is at offset 16 in our task entry
   mov eax_val, [eax_ptr+16]
   mov ebx_val, [edx_ptr+16]
   sub eax_val, ebx_val
   mov [sort_result], eax_val
   jmp .compare_result

.compare_mem:
   ; Memory (4KB pages) is at offset 12 in our task entry
   mov eax_val, [eax_ptr+12]
   mov ebx_val, [edx_ptr+12]
   sub eax_val, ebx_val
   mov [sort_result], eax_val

.compare_result:
   mov eax_comp, [sort_result]
   cmp dword [sortAscending], 1
   je .check_swap
   neg eax_comp

.check_swap:
   cmp eax_comp, 0
   jle .no_swap

   ; Swap records at j and j+1 using a temporary buffer
   mov ecx_count, OUR_TASK_ENTRY_SIZE
   mov esi, eax_ptr            ; Source: record j
   mov edi, temp_record_buffer ; Destination: temp buffer
   rep movsb                   ; Copy record j to temp

   mov ecx_count, OUR_TASK_ENTRY_SIZE
   mov esi, edx_ptr            ; Source: record j+1
   mov edi, eax_ptr            ; Destination: record j's original location
   rep movsb                   ; Copy record j+1 to record j's spot

   mov ecx_count, OUR_TASK_ENTRY_SIZE
   mov esi, temp_record_buffer ; Source: temp buffer (original record j)
   mov edi, edx_ptr            ; Destination: record j+1's original location
   rep movsb                   ; Copy temp to record j+1's spot

.no_swap:
.skip_compare:
   inc edi
   jmp .inner_loop

.inner_loop_done:
   inc esi
   jmp .outer_loop

.outer_loop_done:
.done_sort:
   pop edx
   pop ebx
   pop edi
   pop esi
   pop ebp
   ret


; --------------------------------------------------------------------
; Subroutine: log_event_refresh
; Logs a refresh event.
; --------------------------------------------------------------------
log_event_refresh:
   push dword log_refresh_msg
   call log_event
   ret
log_refresh_msg db "Refresh event occurred.",0

; --------------------------------------------------------------------
; Subroutine: log_event_kill
; Logs a kill event (process ID).
; --------------------------------------------------------------------
log_event_kill:
   push ebx
   mov ebx, [esp+8]
   mov ecx, numbuf
   mov eax, ebx
   call itoa
   push dword log_kill_msg_prefix
   call log_event
   push dword numbuf
   call log_event
   pop ebx
   ret 4
log_kill_msg_prefix db "Killed process ID: ",0

; --------------------------------------------------------------------
; Subroutine: log_event_set_priority
; Logs a set-priority event.
; --------------------------------------------------------------------
log_event_set_priority:
   push dword log_set_priority_msg
   call log_event
   ret
log_set_priority_msg db "Set process priority.",0

; --------------------------------------------------------------------
; Subroutine: log_event
; Appends the null-terminated log message (pointer on stack) to logBuffer.
; --------------------------------------------------------------------
log_event:
   push eax
   push ecx
   push edi
   push esi

   mov esi, [esp+20]
   mov edi, [logPosition]
   add edi, logBuffer

.log_loop:
   mov al, byte [esi]
   cmp al, 0
   je .log_newline
   mov byte [edi], al
   inc esi
   inc edi
   jmp .log_loop
.log_newline:
   mov byte [edi], 10
   inc edi
   sub edi, logBuffer ; Convert back to offset for storage
   mov [logPosition], edi

   pop esi
   pop edi
   pop ecx
   pop eax
   ret 4

; --------------------------------------------------------------------
; Subroutine: itoa
; Converts an unsigned integer in EAX to a null-terminated ASCII string.
; ECX should point to a buffer (numbuf).
; --------------------------------------------------------------------
itoa:
   push ebx
   push edx
   push esi
   push edi

   mov edi, ecx
   add ecx, 31
   mov byte [ecx], 0

.itoa_loop:
   xor edx, edx
   mov ebx, 10
   div ebx
   add dl, '0'
   dec ecx
   mov [ecx], dl
   test eax, eax
   jnz .itoa_loop

   mov esi, ecx
   mov ecx, edi
   sub ecx, esi
   neg ecx

   mov edx, ecx
   mov edi, edi

.shift_loop:
   cmp edx, 0
   je .shift_done
   mov al, byte [esi]
   mov byte [edi], al
   inc esi
   inc edi
   dec edx
   jmp .shift_loop
.shift_done:
   mov byte [edi], 0

   pop edi
   pop esi
   pop edx
   pop ebx
   ret

; --------------------------------------------------------------------
; End of Advanced Task Manager Code
; --------------------------------------------------------------------